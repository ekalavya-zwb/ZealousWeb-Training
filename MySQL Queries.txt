Day 1: MySQL Fundamentals:-

Exercise 1.1: Create a database called company_db:
CREATE DATABASE company_db;
SHOW DATABASES;

Exercise 1.2: Create a table named employees: 
USE company_db;
CREATE TABLE employees(
id INT PRIMARY KEY AUTO_INCREMENT,
first_name VARCHAR(50),
last_name VARCHAR(50),
email VARCHAR(100),
hire_date DATE,
salary DECIMAL
);
SELECT * FROM employees;

Exercise 1.3: Create another table departments: 
CREATE TABLE departments(
dept_id INT PRIMARY KEY AUTO_INCREMENT,
dept_name VARCHAR(50),
location VARCHAR(50)
);
SELECT * FROM departments;

Day 2: MySQL - Data Manipulation & Queries:-

Exercise 2.1: Insert 4 employees into the employees table with different salaries and hire dates:
INSERT INTO employees(id, first_name, last_name, email, hire_date, salary) VALUES (100, "Ekalavya", "Patel", "ekalavya@gmail.com", "2026-01-01", 15000);
INSERT INTO employees(first_name, last_name, email, hire_date, salary) VALUES ("Shubham", "Patel", "shubham@gmail.com", "2026-01-01", 16000);
INSERT INTO employees(first_name, last_name, email, hire_date, salary) VALUES ("Divya", "Gupta", "divya@gmail.com", "2026-01-01", 15000);
INSERT INTO employees(first_name, last_name, email, hire_date, salary) VALUES ("Utkarsh", "Sharma", "utkarsh@gmail.com", "2026-01-01", 14000);

Exercise 2.2: Insert 4 departments into the departments table:
INSERT INTO departments(dept_id, dept_name, location) VALUES (200, "Development", "302");
INSERT INTO departments(dept_name, location) VALUES ("Testing", "301");
INSERT INTO departments(dept_name, location) VALUES ("Development", "302");
INSERT INTO departments(dept_name, location) VALUES ("Designing", "202");
SELECT * FROM departments;

Exercise 2.3: Write queries to:
i).Select all employees
SELECT * FROM employees;

ii).Select only first_name and email of all employees
SELECT first_name, email FROM employees;

iii).Find employees with salary > 50000
SELECT * FROM employees WHERE salary > 50000;

iv).Find employees hired after '2023-01-01'
SELECT * FROM employees WHERE hire_date > "2023-01-01";

v).Count total number of employees
SELECT COUNT(*) AS TotalEmplCount FROM employees;

Exercise 2.4: Update exercises:
i).Increase salary by 10% for a specific employee
UPDATE employees SET salary = salary + (salary * 0.1) WHERE id = 103;

ii).Change department location for a specific department
UPDATE departments SET location = "201" WHERE dept_id = 203;

Exercise 2.5: Advanced queries:
i).Find the highest salary
SELECT MAX(salary) AS HighSal FROM employees;

ii).Find average salary of all employees
SELECT AVG(salary) AS AvgSal FROM employees;

iii).List employees ordered by salary (highest first)
SELECT * FROM employees ORDER BY salary DESC;

iv).Find employees whose first name starts with 'J'
SELECT * FROM employees WHERE first_name LIKE "J%";

v).Get the 3 most recently hired employees
(Doubt)

Exercise 2.6: Delete an employee record and verify deletion:
DELETE FROM employees WHERE id = 100;
SELECT * FROM employees WHERE id = 100;

Comprehensive Exercises:-

Exercise Set 1: JOINs Mastery
1.1 INNER JOIN Exercises:

Q1: List all employees with their department names
SELECT employees.first_name, employees.last_name, departments.dept_name FROM employees JOIN departments ON employees.dept_id = departments.dept_id;

Q2: Show all projects with their department names
SELECT projects.project_name, departments.dept_name FROM projects JOIN departments ON projects.dept_id = departments.dept_id;

Q3: List employees working on projects with project names and their roles
SELECT employees.first_name, employees.last_name, projects.project_name, employee_projects.role FROM ((projects 
JOIN employees ON projects.dept_id = employees.dept_id)
JOIN employee_projects ON projects.project_id = employee_projects.project_id);                                                                                                                  

Q4: Find employees in the Engineering department with salary > 70000
SELECT employees.first_name, employees.last_name, departments.dept_name FROM employees JOIN departments ON employees.dept_id = departments.dept_id 
WHERE employees.salary > 70000;                                                                                                             

1.2 LEFT JOIN Exercises:

Q1: List all employees and their department names (include employees without departments)
SELECT e.id, e.first_name, e.last_name, d.dept_name FROM employees AS e LEFT JOIN departments AS d ON e.dept_id = d.dept_id;

Q2: Show all departments and count of employees in each (include departments with 0 employees)
SELECT d.dept_id, d.dept_name, COUNT(e.id) AS EmplCount FROM departments AS d LEFT JOIN employees AS e ON d.dept_id = e.dept_id GROUP BY d.dept_id;

Q3: List all projects and total hours worked (include projects with no assigned employees)
SELECT p.project_id, p.project_name, SUM(ep.hours_worked) AS Total_Hours FROM projects AS p LEFT JOIN employee_projects AS ep 
ON p.project_id = ep.project_id GROUP BY p.project_id;

1.3 RIGHT JOIN Exercises:

Q1: List all departments and their employees (show all departments even if no employees)
SELECT d.dept_id, d.dept_name, e.first_name, e.last_name FROM employees AS e RIGHT JOIN departments AS d ON e.dept_id = d.dept_id;

Q2: Show all projects with employee assignments (include all projects)
SELECT p.project_name, e.first_name, e.last_name FROM ((employee_projects AS ep
RIGHT JOIN projects AS p ON ep.project_id = p.project_id)
JOIN employees AS e ON ep.emp_id = e.id);

1.4 SELF JOIN Exercise:

Q1: List all employees with their manager's name
SELECT e1.id, e1.first_name, e1.last_name, e2.first_name AS manager_fname, e2.last_name AS manager_lname FROM employees AS e1, employees AS e2 
WHERE e1.manager_id = e2.id;

Q2: Find employees who earn more than their manager
SELECT e1.id, e1.first_name, e1.last_name, e1.salary, e2.first_name AS manager_fname, e2.last_name AS manager_lname, e2.salary FROM employees AS e1, employees AS e2 
WHERE e1.manager_id = e2.id AND e1.salary > e2.salary;

1.5 CROSS JOIN Exercise:

Q1: Create all possible combinations of employees and projects
SELECT e.first_name, e.last_name, p.project_name FROM projects AS p CROSS JOIN employees AS e;

Q2: How many total combinations are there?
SELECT COUNT(*) AS Total_Combinations FROM projects CROSS JOIN employees;

1.6 Multiple JOIN Exercise:

Q1: List employee name, department name, project name, and role for all assignments
SELECT e.first_name, e.last_name, d.dept_name, p.project_name, ep.role FROM ((employee_projects AS ep
JOIN employees AS e ON ep.emp_id = e.id JOIN departments AS d ON e.dept_id = d.dept_id)
JOIN projects AS p ON ep.project_id = p.project_id);

Q2: Find total budget of all projects in each department with department location
SELECT p.project_name, d.dept_name, d.location, SUM(p.budget) AS Total_Budget FROM projects AS p JOIN departments AS d ON p.dept_id = d.dept_id GROUP BY p.project_id;

Exercise Set 2: UNION Operations
2.1 Basic UNION:

Q1: Create a list of all unique locations (from both departments and a hypothetical clients table)
SELECT location FROM departments UNION SELECT location FROM clients;

Q2: Combine employee emails and a fictional customer_emails into one list (remove duplicates)
SELECT email FROM employees UNION SELECT customer_emails FROM clients;

2.2 UNION ALL:

Q1: Get all salaries from employees and all budgets from projects in one list (keep duplicates)
SELECT salary FROM employees UNION ALL SELECT budget FROM projects;

Q2: Create a complete activity log showing all hire_dates and project start_dates
SELECT hire_date AS ActivityLog FROM employees UNION ALL SELECT start_date FROM projects;

2.3 Advanced UNION:

Q1: Create a report showing:
 - All employees with their salary labeled as 'Employee Salary'
 - All projects with their budget labeled as 'Project Budget'
 - Order the combined result by amount

(Doubt)

Exercise Set 3: Subqueries
3.1 Subqueries in WHERE:

Q1: Find employees whose salary is above the average salary
SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);

Q2: List employees working in departments located in 'New York'
SELECT first_name, last_name FROM employees WHERE dept_id IN (SELECT dept_id FROM departments WHERE location = "New York");

Q3: Find employees who are NOT assigned to any project
SELECT first_name, last_name FROM employees WHERE id IN (SELECT emp_id FROM employee_projects WHERE project_id IS NULL);

Q4: Get employees who work on projects with budget > 100000
SELECT first_name, last_name FROM employees WHERE id IN 
(SELECT ep.emp_id FROM employee_projects AS ep JOIN projects AS p ON ep.project_id = p.project_id WHERE p.budget > 100000);

Q5: Find the employee(s) with the highest salary
SELECT * FROM employees WHERE salary = (SELECT MAX(salary) FROM employees);

3.2 Subqueries with IN:

Q1: Find employees who work in either Engineering or Marketing
SELECT * FROM employees WHERE dept_id IN (SELECT dept_id FROM departments WHERE dept_name = "Engineering" OR dept_name = "Marketing");

Q2: List projects that have at least one employee assigned
SELECT ep.project_id, p.project_name, COUNT(ep.emp_id) AS emp_count 
FROM employee_projects ep
JOIN projects p
ON ep.project_id = p.project_id
WHERE ep.project_id IN(
SELECT project_id FROM projects
)
GROUP BY project_id
HAVING COUNT(ep.emp_id) >= 1;

Q3: Find departments that have no projects
SELECT dept_id, dept_name 
FROM departments d
WHERE dept_id NOT IN (
SELECT dept_id FROM projects
);

3.3 Subqueries with EXISTS:

Q1: Find departments that have at least one employee
SELECT d.dept_id, d.dept_name 
FROM departments d
WHERE EXISTS (
SELECT 1
FROM employees e
WHERE e.dept_id = d.dept_id
);

Q2: List employees who are assigned to at least one project
SELECT e.id, e.first_name, e.last_name
FROM employees e
WHERE EXISTS (
SELECT 1
FROM employee_projects ep
WHERE ep.emp_id = e.id
)

Q3: Find projects with budget greater than any employee's salary in that department
SELECT p.project_id, p.project_name, p.budget
FROM projects p
WHERE EXISTS (
SELECT 1
FROM employees e
WHERE e.salary < p.budget
AND e.dept_id = p.dept_id 
);

3.4 Subqueries in SELECT:

Q1: List all employees with a column showing how much more/less they earn compared to average
SELECT id, first_name, last_name, salary, 
ROUND(salary - (SELECT AVG(salary) FROM employees), 2) AS sal_diff
FROM employees;

Q2: Show each department with the count of employees and count of projects
SELECT d.dept_id, d.dept_name, COUNT(DISTINCT e.id) AS emp_count, COUNT(DISTINCT p.project_id) AS project_count
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
LEFT JOIN projects p ON d.dept_id = p.dept_id
GROUP BY d.dept_id, d.dept_name;

3.5 Subqueries in FROM (Derived Tables):

Q1: Find the average salary per department, then find departments with above-overall-average dept salary
(Doubt)

Q2: Get the top 3 highest-paid employees from each department
(Doubt)

3.6 Correlated Subqueries:

Q1: Find employees who earn more than the average salary in their department
(Doubt)

Q2: List employees who work more hours than the average for their project
(Doubt)

Exercise Set 4: GROUP BY & HAVING
4.1 Basic GROUP BY:

Q1: Count employees in each department
SELECT d.dept_name, COUNT(e.id) AS EmplCount FROM employees AS e JOIN departments AS d ON e.dept_id = d.dept_id GROUP BY dept_name; 

Q2: Calculate total and average salary per department
SELECT d.dept_name, SUM(e.salary) AS TotalSal, AVG(e.salary) AS AvgSal FROM employees AS e JOIN departments AS d ON e.dept_id = d.dept_id GROUP BY d.dept_name;

Q3: Find total hours worked per project
SELECT p.project_name, SUM(ep.hours_worked) AS TotalHours FROM projects AS p JOIN employee_projects AS ep ON p.project_id = ep.project_id GROUP BY p.project_name;

Q4: Count number of projects per department
SELECT d.dept_name, COUNT(p.project_id) AS ProjectsCount FROM projects AS p JOIN departments AS d ON p.dept_id = d.dept_id GROUP BY d.dept_name;

4.2 HAVING Clause:

Q1: Find departments with more than 2 employees
SELECT d.dept_name, COUNT(e.id) AS EmplCount FROM employees AS e JOIN departments AS d ON e.dept_id = d.dept_id GROUP BY d.dept_name HAVING COUNT(e.id) > 2;

Q2: List projects where total hours worked > 500
SELECT p.project_name, SUM(ep.hours_worked) AS TotalHours FROM projects AS p JOIN employee_projects AS ep ON p.project_id = ep.project_id GROUP BY p.project_name 
HAVING SUM(ep.hours_worked) > 500;

Q3: Find departments with average salary > 65000
SELECT d.dept_name, AVG(e.salary) AS AvgSalary FROM departments AS d JOIN employees AS e ON d.dept_id = e.dept_id GROUP BY d.dept_name HAVING AVG(e.salary) > 65000;

Q4: Show employees who work on more than 1 project
SELECT e.id, e.first_name, e.last_name, COUNT(p.project_id) AS Projects_Count FROM ((employee_projects AS ep 
JOIN employees AS e ON ep.emp_id = e.id)
JOIN projects AS p ON ep.project_id = p.project_id)
GROUP BY e.id HAVING COUNT(p.project_id) > 1 ORDER BY e.id;

4.3 Advanced Grouping:

Q1: For each department, show min, max, and average salary
SELECT d.dept_name, MIN(e.salary) AS MinSal, MAX(e.salary) AS MaxSal, AVG(e.salary) AS AvgSal FROM employees AS e JOIN departments AS d ON e.dept_id = d.dept_id 
GROUP BY d.dept_name;

Q2: Find the department with the highest total salary payout
(Doubt)

Q3: List projects with their employee count and total hours, only where employee count > 2
SELECT p.project_name, COUNT(ep.emp_id) AS Empl_Count, SUM(ep.hours_worked) AS TotalHours FROM employee_projects AS ep JOIN projects AS p ON ep.project_id = p.project_id 
GROUP BY p.project_name HAVING COUNT(ep.emp_id) > 2;

Q4: Group by multiple columns: department and hire year, count employees
SELECT d.dept_name, YEAR(e.hire_date) AS hire_year, COUNT(e.id) AS EmplCount FROM employees AS e JOIN departments AS d ON e.dept_id = d.dept_id 
GROUP BY d.dept_name, YEAR(e.hire_date) ORDER BY hire_year;

Exercise Set 5: Advanced String Functions

Q1: Display full name (first + last) in uppercase for all employees
SELECT CONCAT(UCASE(first_name), " ", UCASE(last_name)) AS FullName FROM employees;

Q2: Create email usernames (part before @) from employee emails
SELECT SUBSTRING_INDEX(email, "@", 1) AS Username FROM employees;

Q3: Find employees whose last name contains 'son'
SELECT * FROM employees WHERE LOCATE("son", last_name) != 0;

Q4: Display employee names with first letter of first name + full last name (e.g., "J. Doe")
SELECT CONCAT(SUBSTR(first_name, 1, 1), ".", last_name) FROM employees;

Q5: Replace all 'New York' locations with 'NY' in departments
SELECT dept_id, dept_name, REPLACE(LOCATION, "New York", "NY") AS location FROM departments;

Q6: Find length of each project name and order by length
SELECT project_name, LENGTH(project_name) AS ProjNameLen FROM projects ORDER BY LENGTH(project_name);

Q7: Extract domain name from employee emails
SELECT SUBSTRING_INDEX(email, "@", -1) AS Domain FROM employees;

Exercise Set 6: Date Functions

Q1: Calculate how many days each employee has been with the company
SELECT first_name, last_name, DATEDIFF(CURRENT_DATE, hire_date) AS TotalDays FROM employees;

Q2: Find employees hired in 2022
SELECT first_name, last_name, YEAR(hire_date) AS hire_year FROM employees WHERE YEAR(hire_date) = "2022";

Q3: Calculate project duration in days
SELECT project_id, project_name, DATEDIFF(end_date, start_date) AS Duration FROM projects;

Q4: Find employees who will celebrate their 2-year anniversary in the next 90 days
(Doubt)

Q5: Show month name when each employee was hired
SELECT first_name, last_name, MONTHNAME(hire_date) AS hire_month FROM employees;

Q6: Calculate average tenure of employees in each department
(Doubt)

Q7: Find projects that lasted more than 6 months
SELECT project_id, project_name, (MONTH(end_date) - MONTH(start_date)) AS Months FROM projects WHERE (MONTH(end_date) - MONTH(start_date)) > 6;

Q8: Display hire_date in format 'DD-MM-YYYY'
(Doubt)

Exercise Set 7: CASE Statements

Q1: Categorize employees as 'High Earner' (>75k), 'Medium Earner' (50k-75k), 'Entry Level' (<50k)
SELECT first_name, last_name, salary,
CASE 
	WHEN salary > 75000 THEN "High Earner"
    WHEN salary BETWEEN 50000 AND 75000 THEN "Medium Earner"
    ELSE "Entry Level"
END AS CategoryText
FROM employees;

Q2: Label projects as 'Small' (<100k), 'Medium' (100k-150k), 'Large' (>150k) based on budget
SELECT project_id, project_name, budget,
CASE 
	WHEN budget > 150000 THEN "Large"
    WHEN budget BETWEEN 100000 AND 150000 THEN "Medium"
    ELSE "Small"
END AS CategoryText
FROM projects;

Q3: Create seniority levels based on hire date (Senior: before 2022, Mid: 2022, Junior: after 2022)
SELECT first_name, last_name, YEAR(hire_date) AS hire_year,
CASE 
	WHEN YEAR(hire_date) > 2022 THEN "Junior"
    WHEN YEAR(hire_date) < 2022 THEN "Senior"
    ELSE "Intermediate"
END AS CategoryText
FROM employees;

Q4: Show if employee salary is 'Above Average', 'Average', or 'Below Average'
SELECT id, first_name, last_name, salary,
CASE 
	WHEN salary > (SELECT AVG(salary) FROM employees) THEN "Above Average"
    WHEN salary < (SELECT AVG(salary) FROM employees) THEN "Below Average"
    ELSE "Average"
END AS CategoryText
FROM employees;

Q5: Create a bonus column: 10% for Engineering, 8% for Sales, 5% for others
SELECT e.first_name, e.last_name, d.dept_name,
CASE 
	WHEN d.dept_name = "Engineering" THEN e.salary * 0.1
    WHEN  d.dept_name = "Sales" THEN e.salary * 0.08
    ELSE e.salary * 0.05
END AS bonus
FROM employees AS e JOIN departments AS d ON e.dept_id = d.dept_id;

Exercise Set 8: Indexes

Q1: Create an index on the email column of employees table
CREATE INDEX idx_email ON employees (email);

Q2: Create a composite index on dept_id and salary
CREATE INDEX idx_empSalary ON employees (id, salary);

Q3: Create a unique index on employee email
CREATE INDEX idx_uniqueEmail ON employees (email);

Q4: Show all indexes on the employees table
SHOW INDEX from employees;

Q5: Measure query performance before and after creating index on large dataset
// Before creating index
SELECT email FROM employees;  (Query took 0.0004 seconds)
// After creating index
SELECT email FROM employees;  (Query took 0.0003 seconds)

Q6: When would you NOT want to create an index? (Discussion question)
Updating a table with indexes takes more time than updating a table without (because the indexes also need an update).
So, only create indexes on columns that will be frequently searched against.

Exercise Set 9: Views

Q1: Create a view 'employee_details' showing employee name, department, and salary
CREATE VIEW employee_details AS
SELECT e.first_name, e.last_name, d.dept_name, e.salary
FROM employees AS e JOIN departments AS d
ON e.dept_id = d.dept_id;

SELECT * FROM employee_details;

Q2: Create a view 'project_summary' with project name, department, employee count, total hours
CREATE VIEW project_summary AS
SELECT p.project_name, d.dept_name, COUNT(ep.emp_id) AS EmpCount, SUM(ep.hours_worked) AS TotalHours
FROM ((employee_projects AS ep
JOIN projects AS p ON ep.project_id = p.project_id)
JOIN departments AS d ON p.dept_id = d.dept_id)
GROUP BY p.project_name, d.dept_name;

SELECT * FROM project_summary;

Q3: Create a view showing high earners (salary > 70000) with their projects
CREATE VIEW high_earners AS
SELECT e.first_name, e.last_name, p.project_name, e.salary
FROM ((employee_projects AS ep
JOIN projects AS p ON ep.project_id = p.project_id)
JOIN employees AS e ON ep.emp_id = e.id)
WHERE e.salary > 70000;

SELECT * FROM high_earners;

Q4: Update a record through a view and verify
CREATE OR REPLACE VIEW high_earners AS
SELECT e.first_name, e.last_name, p.project_name, ep.role, e.salary
FROM ((employee_projects AS ep
JOIN projects AS p ON ep.project_id = p.project_id)
JOIN employees AS e ON ep.emp_id = e.id)
WHERE e.salary > 70000;

SELECT * FROM high_earners;

Q5: Create a view showing department-wise statistics (emp count, avg salary, total salary)
CREATE VIEW dept_stats AS
SELECT d.dept_name, COUNT(e.id) AS EmpCount, SUM(e.salary) AS TotalSal, AVG(e.salary) AS AvgSal
FROM employees AS e JOIN departments AS d
ON e.dept_id = d.dept_id
GROUP BY d.dept_name;

SELECT * FROM dept_stats;

Exercise Set 10: Transactions

Q1: Transfer an employee from one department to another (update + log entry) in a transaction
CREATE TABLE transfer_log (log_id INT PRIMARY KEY AUTO_INCREMENT, emp_id INT, old_dept_id INT, new_dept_id INT, transfer_date DATETIME);

START TRANSACTION;

SET @old_dept_id = (
    SELECT dept_id 
    FROM employees 
    WHERE id = 5
);

UPDATE employees
SET dept_id = 3
WHERE id = 5;

INSERT INTO transfer_log (emp_id, old_dept_id, new_dept_id, transfer_date)
VALUES (5, @old_dept_id, 3, NOW());

COMMIT;

Q2: Give a raise to all employees in a department and log it (rollback if error)
CREATE TABLE salary_raise_log (log_id INT PRIMARY KEY AUTO_INCREMENT, dept_id INT, raise_percent VARCHAR(255), changed_on DATETIME);

START TRANSACTION;

UPDATE employees
SET salary = salary + salary * 0.1
WHERE dept_id = 2;

INSERT INTO salary_raise_log (dept_id, raise_percent, changed_on)
VALUES (2, "10%", NOW());

COMMIT;

Q3: Create a savepoint scenario: add new project, assign employees, rollback employee assignment only
START TRANSACTION;

INSERT INTO projects (project_id, project_name, start_date, end_date, budget, dept_id)
VALUES (6, "ERP Portal", "2023-03-23", "2023-08-12", 100000, 1);

SAVEPOINT new_project;

INSERT INTO employee_projects (emp_id, project_id, hours_worked, role)
VALUES (1, 6, 250, "Frontend Developer");

INSERT INTO employee_projects (emp_id, project_id, hours_worked, role)
VALUES (2, 6, 250, "Backend Developer");

ROLLBACK TO new_project;

COMMIT;

Q4: Simulate a failed transaction and demonstrate rollback
START TRANSACTION;

UPDATE employees
SET salary = salary + salary * 0.1
WHERE dept_id = 1;

INSERT INTO salary_raise_log (dept_id, raise_percent, changed_on)
VALUES (1, "10%", NOW());

ROLLBACK;

Q5: Practice: Update multiple tables atomically (employee salary + salaries_history table)
START TRANSACTION;

SET @old_salary = (
    SELECT salary 
    FROM employees 
    WHERE id = 6
);

UPDATE employees
SET salary = salary + salary * 0.1
WHERE id = 6;

SET @new_salary = (
    SELECT salary 
    FROM employees 
    WHERE id = 6
);

INSERT INTO salaries_history (emp_id, old_salary, new_salary, change_date)
VALUES (6, @old_salary, @new_salary, CURDATE());

COMMIT;

Exercise Set 11: Stored Procedures (Introduction)

Q1: Create a procedure to get all employees in a specific department (IN parameter)
DELIMITER $$

CREATE PROCEDURE getAllEmployeesByDept (IN dept_no INT)
BEGIN
SELECT * FROM employees
WHERE dept_id = dept_no;
END $$

DELIMITER ;

CALL getAllEmployeesByDept(3);

Q2: Create a procedure to calculate and return average salary of a department (IN and OUT parameters)
DELIMITER $$

CREATE PROCEDURE getAvgSal (
    IN dept_no INT, 
    OUT avg_sal DECIMAL(10,2)
)
BEGIN
SELECT AVG(salary) INTO avg_sal
FROM employees
WHERE dept_id = dept_no;
END $$

DELIMITER ;

CALL getAvgSal(3, @avg);
SELECT @avg AS Avg_Sal;

Q3: Create a procedure to give a raise to an employee (IN: emp_id, raise_percent)
DELIMITER $$

CREATE PROCEDURE giveSalRaise (
    IN emp_id INT, 
    IN raise_percent DECIMAL(10,2)
)
BEGIN
UPDATE employees
SET salary = salary + (salary * raise_percent)
WHERE id = emp_id;
END $$

DELIMITER ;

SET @raise_per = 0.1;
CALL giveSalRaise(3, @raise_per);

Q4: Create a procedure to get employee count per department
DELIMITER $$

CREATE PROCEDURE getEmpCountByDept (
    IN dept_no INT,
    OUT emp_count INT
)
BEGIN
SELECT COUNT(id) INTO emp_count
FROM employees
WHERE dept_id = dept_no;
END $$

DELIMITER ;

CALL getEmpCountByDept(3, @count);
SELECT @count AS Emp_Count;

Q5: Create a procedure that assigns an employee to a project
DELIMITER $$

CREATE PROCEDURE assignEmp (
    IN emp_id INT,
    IN project_id INT,
    IN hours_worked INT,
    IN role VARCHAR(255)
)
BEGIN
INSERT INTO employee_projects (emp_id, project_id, hours_worked, role)
VALUES (emp_id, project_id, hours_worked, role);
END $$

DELIMITER ;

CALL assignEmp(1, 6, 100, "Frontend Developer");

Sorry an unexpected error happened!


Level 1: Hard SQL + Data Integrity Challenges
Exercise 1: Salary Audit Engine (Pure SQL)

DELIMITER $$

CREATE TRIGGER update_sal 
BEFORE UPDATE
ON employees
FOR EACH ROW
BEGIN
    IF NEW.salary < OLD.salary * 0.8 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Salary reduction cannot exceed 20%';
    END IF;

    IF NEW.salary <> OLD.salary THEN
        INSERT INTO salaries_history (emp_id, old_salary, new_salary, change_date)
        VALUES (OLD.id, OLD.salary, NEW.salary, NOW());
    END IF;
END $$

DELIMITER ;

UPDATE employees SET salary = salary * 0.6 WHERE id = 1; // Fails

Exercise 2: Project Cost Overrun Detector

SELECT p.project_name, p.budget, ROUND(SUM(ep.hours_worked * (e.salary / (22 * 8))),2) AS actual_cost, 
CASE
	WHEN SUM(ep.hours_worked * (e.salary / (22 * 8))) > p.budget THEN "OVER_BUDGET"
    ELSE "IN_BUDGET"
END AS Status
FROM employee_projects ep 
JOIN projects p ON ep.project_id = p.project_id
JOIN employees e ON ep.emp_id = e.id
GROUP BY p.project_id, p.project_name, p.budget;

Exercise 3: Department Performance Ranking
(Doubt)

Level 2: Stored Procedure Hell Mode 
Exercise 4: Atomic Employee Termination Procedure

DELIMITER $$

CREATE PROCEDURE terminate_employee(
    IN p_emp_id INT, 
    IN ptermination_reason VARCHAR(255)
)
BEGIN
DECLARE emp_exist INT;
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
    ROLLBACK;
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Termination failed!';
END;
START TRANSACTION;

SELECT COUNT(*) INTO emp_exist 
FROM employees 
WHERE id = p_emp_id;

IF emp_exist = 0 THEN
	ROLLBACK;
	SIGNAL SQLSTATE "45000"
    SET MESSAGE_TEXT = "Employee not found!";
END IF;

INSERT INTO terminated_employees (id, first_name, last_name, email, hire_date, salary, dept_id, manager_id, termination_reason, termination_at)
SELECT id, first_name, last_name, email, hire_date, salary, dept_id, manager_id, ptermination_reason, NOW()
FROM employees
WHERE id = p_emp_id;

DELETE FROM employee_projects
WHERE emp_id = p_emp_id;

DELETE FROM employees
WHERE id = p_emp_id;

COMMIT;
END $$

DELIMITER ;

CALL terminate_employee(9,"Didn't show any progress");

Exercise 5: Bulk Project Assignment Procedure

DELIMITER $$

CREATE PROCEDURE assign_project_bulk(
    IN p_project_id INT, 
    IN p_dept_id INT
)
BEGIN
DECLARE v_skipped INT DEFAULT 0;
DECLARE v_assigned INT DEFAULT 0;

DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
    ROLLBACK;
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Employees assignment failed!';
END;
START TRANSACTION;

SELECT COUNT(*) 
INTO v_skipped
FROM employees e
JOIN employee_projects ep
ON ep.emp_id = e.id
WHERE ep.project_id = p_project_id AND
e.dept_id = p_dept_id;

INSERT INTO employee_projects(emp_id, project_id, hours_worked, role)
SELECT e.id, p_project_id, 0, "Contributor" 
FROM employees e
LEFT JOIN employee_projects ep
ON ep.emp_id = e.id
AND ep.project_id = p_project_id
WHERE e.dept_id = p_dept_id
AND ep.emp_id IS NULL;

SET v_assigned = ROW_COUNT();

COMMIT;

SELECT 
	v_assigned AS assigned,
	v_skipped AS skipped;
END $$

DELIMITER ;

CALL assign_project_bulk(7,1);